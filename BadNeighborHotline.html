<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bad Neighbor Hotline â€” Unscramble Replies</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*{margin:0;padding:0;box-sizing:border-box;font-family:Segoe UI,system-ui,sans-serif;color:#333;}
body{background:#f8fafc;display:flex;flex-direction:column;align-items:center;padding:10px;gap:10px;touch-action:none;}
h2{text-align:center;}
.wrapper{width:100%;max-width:800px;display:flex;flex-direction:column;gap:10px;}
#chat{border:2px solid #cbd5e1;border-radius:8px;background:#eef6f9;padding:10px;min-height:400px;display:flex;flex-direction:column;gap:10px;overflow-y:auto;}
#chat p { text-align:left; }

.word-container {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 10px;
}
.word {
  padding: 8px 12px;
  background-color: #cbd5e1;
  border: 2px solid #94a3b8; 
  border-radius: 6px;
  cursor: grab;
  user-select: none;
  transition: transform 0.2s, background-color 0.2s, border-color 0.2s;
  touch-action: none; /* Important for touch devices */
  position: relative; /* For positioning during drag */
  z-index: 1; /* Default z-index */
}
.word.dragging {
  opacity: 0.7;
  background-color: #94a3b8;
  z-index: 1000; /* Bring to front when dragging */
  position: relative;
}
.result {
  font-size: 18px;
  margin-top: 10px;
  text-align: center;
}
button {
  padding: 8px 16px;
  font-size: 16px;
  border: 2px solid #94a3b8;
  border-radius: 6px;
  background-color: #cbd5e1;
  cursor: pointer;
  transition: background-color 0.2s;
}
button:hover {
  background-color: #94a3b8;
  color: white;
}
.student-bubble {
  align-self: flex-end;
  background-color: #94a3b8;
  color: white;
  padding: 10px 14px;
  border-radius: 12px;
  max-width: 60%;
  margin-top: 10px;
}
</style>
</head>
<body>

<div class="wrapper">
  <h2>Unscramble the sentence</h2>

  <div id="chat">
    <!-- fixed part of sentence -->
    <p id="sentence-text"></p>
    <div class="word-container" id="word-container"></div>
  </div>

  <button id="checkBtn" onclick="checkAnswer()">Check Answer</button>
  <div class="result" id="result"></div>
</div>

<script>
// List of prompts with parts to shuffle in !!
const prompts = [
  "Hello, Bad Neighbor Hotline. Iâ€™m really sorry youâ€™re dealing with this. Can you tell me !!what has been happening?!!",
  "Oh wowâ€¦ that sounds stressful. !!When did this first happen?!!",
  "So this wasnâ€™t just one time, right? !!How often did this happen?!!",
  "I can imagine how frustrating that must be. !!How has this situation affected you personally?!!",
  "Thatâ€™s really hard. !!Have you already tried to solve the problem?!!",
  "And !!how did your neighbors react?!!",
  "I seeâ€¦ !!Have you spoken to your landlord about it?!!",
  "Since then, !!has anything improved?!!",
  "Thank you for sharing all of that. It sounds like youâ€™ve been under a lot of stress, and Iâ€™m glad you reached out."
];

let currentPrompt = 0;
let correctWords = [];
let scrambledWords = [];

const sentenceText = document.getElementById('sentence-text');
const container = document.getElementById('word-container');
const resultDiv = document.getElementById('result');
const chat = document.getElementById('chat');
const checkBtn = document.getElementById('checkBtn');

// Variables for touch handling
let dragged = null;
let touchStartX = 0;
let touchStartY = 0;
let isTouchDragging = false;
let touchDragOffsetX = 0;
let touchDragOffsetY = 0;

// Shuffle array
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Load the current prompt
function loadPrompt() {
  container.innerHTML = '';
  resultDiv.textContent = '';
  checkBtn.disabled = false;

  if (currentPrompt >= prompts.length) {
    sentenceText.textContent = "All prompts completed!";
    container.innerHTML = '';
    checkBtn.style.display = "none";
    return;
  }

  const prompt = prompts[currentPrompt];

  // Extract the part inside !!
  const match = prompt.match(/!!(.*?)!!/);
  if (match) {
    correctWords = match[1].trim().split(" ");
    scrambledWords = shuffle([...correctWords]); // shuffle words
  } else {
    correctWords = [];
    scrambledWords = [];
  }

  // Fixed part outside !!
  const fixedPart = prompt.replace(/!!.*?!!/, '').trim();
  sentenceText.textContent = fixedPart;

  // Create draggable word blocks
  scrambledWords.forEach(word => {
    const div = document.createElement('div');
    div.textContent = word;
    div.className = 'word';
    div.draggable = true;
    container.appendChild(div);
  });

  addDragEvents();
}

// Combined drag & drop and touch logic
function addDragEvents() {
  container.querySelectorAll('.word').forEach(word => {
    // Mouse events
    word.addEventListener('dragstart', handleDragStart);
    word.addEventListener('dragend', handleDragEnd);
    
    // Touch events
    word.addEventListener('touchstart', handleTouchStart);
    word.addEventListener('touchmove', handleTouchMove);
    word.addEventListener('touchend', handleTouchEnd);
    
    // Prevent context menu on long press
    word.addEventListener('contextmenu', e => e.preventDefault());
  });

  // Mouse drag over
  container.addEventListener('dragover', handleDragOver);
  
  // Touch events for container
  container.addEventListener('touchmove', handleContainerTouchMove, { passive: false });
  container.addEventListener('touchend', handleContainerTouchEnd);
}

function handleDragStart(e) {
  dragged = e.target;
  e.target.classList.add('dragging');
  e.dataTransfer.setData('text/plain', ''); // Required for Firefox
  resetBorders();
}

function handleDragEnd(e) {
  dragged = null;
  e.target.classList.remove('dragging');
}

function handleDragOver(e) {
  e.preventDefault();
  const afterElement = getDragAfterElement(container, e.clientX);
  if (afterElement == null) container.appendChild(dragged);
  else container.insertBefore(dragged, afterElement);
}

function getDragAfterElement(container, x) {
  const draggableElements = [...container.querySelectorAll('.word:not(.dragging)')];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = x - box.left - box.width / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Touch handling functions
function handleTouchStart(e) {
  e.preventDefault();
  const touch = e.touches[0];
  dragged = e.target;
  isTouchDragging = true;
  
  // Store initial touch position
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  
  // Get element position
  const rect = dragged.getBoundingClientRect();
  touchDragOffsetX = touch.clientX - rect.left;
  touchDragOffsetY = touch.clientY - rect.top;
  
  dragged.classList.add('dragging');
  resetBorders();
  
  // Bring to front
  dragged.style.position = 'fixed';
  dragged.style.left = rect.left + 'px';
  dragged.style.top = rect.top + 'px';
  dragged.style.zIndex = '1000';
  dragged.style.transform = 'scale(1.1)';
}

function handleTouchMove(e) {
  if (!isTouchDragging || !dragged) return;
  
  e.preventDefault();
  const touch = e.touches[0];
  
  // Move the element
  dragged.style.left = (touch.clientX - touchDragOffsetX) + 'px';
  dragged.style.top = (touch.clientY - touchDragOffsetY) + 'px';
}

function handleTouchEnd(e) {
  if (!isTouchDragging || !dragged) return;
  
  isTouchDragging = false;
  
  // Reset styles
  dragged.classList.remove('dragging');
  dragged.style.position = '';
  dragged.style.left = '';
  dragged.style.top = '';
  dragged.style.zIndex = '';
  dragged.style.transform = '';
  
  // Find drop position
  const touch = e.changedTouches[0];
  const elements = [...container.querySelectorAll('.word')];
  const droppedIndex = getTouchDropIndex(touch.clientX, touch.clientY, elements);
  
  // Reorder in container
  if (droppedIndex !== -1 && dragged !== elements[droppedIndex]) {
    if (droppedIndex === elements.length - 1) {
      container.appendChild(dragged);
    } else {
      container.insertBefore(dragged, elements[droppedIndex]);
    }
  }
  
  dragged = null;
}

function handleContainerTouchMove(e) {
  if (isTouchDragging) {
    e.preventDefault();
  }
}

function handleContainerTouchEnd() {
  // Additional cleanup if needed
}

function getTouchDropIndex(x, y, elements) {
  for (let i = 0; i < elements.length; i++) {
    const elem = elements[i];
    const rect = elem.getBoundingClientRect();
    
    // Check if touch is near this element
    if (x >= rect.left && x <= rect.right && 
        y >= rect.top && y <= rect.bottom) {
      return i;
    }
  }
  return -1;
}

function resetBorders() {
  [...container.children].forEach(word => word.style.borderColor = '#94a3b8');
}

// Check answer
function checkAnswer() {
  const words = [...container.children].map(w => w.textContent);
  let isAllCorrect = true;

  [...container.children].forEach((wordDiv, i) => {
    if (words[i] === correctWords[i]) wordDiv.style.borderColor = '#4fa46b';
    else {
      wordDiv.style.borderColor = '#c05b6d';
      isAllCorrect = false;
    }
  });

  if (isAllCorrect || correctWords.length === 0) {
    showStudentReply();
  } else {
    resultDiv.textContent = "Some words are incorrect. Try again.";
    resultDiv.style.color = "red";
  }
}

// Student bubble & Next button
function showStudentReply() {
  resultDiv.textContent = "Correct! ðŸŽ‰";
  resultDiv.style.color = "green";

  const bubble = document.createElement('div');
  bubble.className = 'student-bubble';
  bubble.textContent = "Give your reply";
  chat.appendChild(bubble);
  chat.scrollTop = chat.scrollHeight;

  const nextBtn = document.createElement('button');
  nextBtn.textContent = "Next";
  nextBtn.onclick = () => {
    bubble.remove();
    nextBtn.remove();
    currentPrompt++;
    loadPrompt();
  };
  chat.appendChild(nextBtn);
  chat.scrollTop = chat.scrollHeight;

  checkBtn.disabled = true;
}

// Initialize first prompt
loadPrompt();
</script>
</body>
</html>
